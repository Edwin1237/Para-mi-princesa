<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Romantic Engine Pro - Mobile Edition</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; touch-action: none; }
        
        /* Ajuste de firma para móvil */
        #signature {
            position: absolute;
            top: 15px;
            right: 15px;
            color: #ff4d6d;
            font-size: 0.9rem; /* Un poco más pequeño en móvil */
            letter-spacing: 1px;
            z-index: 100;
            text-shadow: 0 0 8px rgba(255, 77, 109, 0.5);
        }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; flex-direction: column; justify-content: center;
            align-items: center; z-index: 1000; transition: opacity 0.8s;
        }

        h1 { 
            color: #ff4d6d; 
            letter-spacing: 2px; 
            margin-bottom: 30px; 
            font-weight: 300; 
            text-align: center; 
            padding: 0 20px;
            font-size: 1.5rem; /* Adaptable */
        }

        #start-btn {
            padding: 12px 30px; background: none; border: 1px solid #ff4d6d;
            color: #ff4d6d; cursor: pointer; letter-spacing: 2px; font-weight: bold;
            text-transform: uppercase;
        }
        
        /* Video miniatura ajustado para no estorbar tanto en móvil */
        #video-container {
            position: absolute; bottom: 10px; left: 10px;
            width: 100px; height: 130px; border: 1px solid #ff4d6d;
            border-radius: 8px; overflow: hidden; z-index: 10; opacity: 0.5;
        }
        #video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    </style>
</head>
<body>

    <div id="signature">con mucho amor tu principe</div>

    <div id="overlay">
        <h1>BIENVENIDA MI PRINCESA</h1>
        <button id="start-btn">INICIALIZAR</button>
    </div>

    <div id="video-container">
        <video id="video" playsinline></video>
    </div>
    
    <div id="canvas-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // ... (Mantener la constante MESSAGES igual que antes) ...
        const MESSAGES = ["Te amo más de lo que las palabras pueden explicar.", "Eres mi lugar seguro.", "Tu sonrisa es mi paz.", "Gracias por existir."]; 

        let scene, camera, renderer, particles, petals;
        const particleCount = 15000; // Reducido para mejor performance en móviles
        let targetPositions = new Float32Array(particleCount * 3);
        let currentMsgIndex = -1; 
        let isFist = false;
        const LERP_SPEED = 0.12; 

        function init() {
            scene = new THREE.Scene();
            // Ajuste de FOV para pantallas verticales de celular
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 1, 3000);
            camera.position.z = 900;

            renderer = new THREE.WebGLRenderer({ antialias: false }); // Antialias off para ahorrar batería
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limitar resolución
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            for(let i=0; i<particleCount*3; i++) {
                positions[i] = (Math.random() - 0.5) * 2000;
                targetPositions[i] = positions[i];
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                size: 3, color: 0xff4d6d, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending
            });
            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            window.addEventListener('resize', onWindowResize);
            createTextShape("Mueve tu mano");
            animate();
        }

        function createTextShape(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1024; canvas.height = 1024; // Formato cuadrado para móvil
            ctx.fillStyle = 'white';
            ctx.font = 'bold 60px sans-serif';
            ctx.textAlign = 'center';
            
            // Ajuste de texto multilínea para pantallas angostas
            const words = text.split(' ');
            let line = '';
            let y = 400;
            for(let n = 0; n < words.length; n++) {
                let testLine = line + words[n] + ' ';
                if (testLine.length > 15) {
                    ctx.fillText(line, 512, y);
                    line = words[n] + ' ';
                    y += 70;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, 512, y);

            const data = ctx.getImageData(0, 0, 1024, 1024).data;
            const points = [];
            for (let y = 0; y < 1024; y += 8) {
                for (let x = 0; x < 1024; x += 8) {
                    if (data[(y * 1024 + x) * 4 + 3] > 128) {
                        points.push((x - 512) * 1.2, (512 - y) * 1.2, 0);
                    }
                }
            }

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                if (i < points.length / 3) {
                    targetPositions[i3] = points[i*3];
                    targetPositions[i3+1] = points[i*3+1];
                    targetPositions[i3+2] = 0;
                } else {
                    targetPositions[i3] = (Math.random() - 0.5) * 1500;
                    targetPositions[i3+1] = (Math.random() - 0.5) * 1500;
                    targetPositions[i3+2] = -1000;
                }
            }
        }

        function createHeart() {
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const t = Math.random() * Math.PI * 2;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                targetPositions[i3] = x * 15; 
                targetPositions[i3+1] = y * 15;
                targetPositions[i3+2] = (Math.random() - 0.5) * 50;
            }
        }

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        
        hands.setOptions({ 
            maxNumHands: 1, 
            modelComplexity: 0, // 0 es más rápido para móviles
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5 
        });
        
        hands.onResults(results => {
            if (results.multiHandLandmarks && results.multiHandLandmarks[0]) {
                const lm = results.multiHandLandmarks[0];
                const indexTip = lm[8];
                const palm = lm[0];

                // Movimiento suavizado
                const targetX = (0.5 - indexTip.x) * 500;
                const targetY = (0.5 - indexTip.y) * 700;
                particles.position.lerp(new THREE.Vector3(targetX, targetY, 0), 0.1);

                const dist = Math.hypot(indexTip.x - palm.x, indexTip.y - palm.y);
                if (dist < 0.15 && !isFist) { 
                    isFist = true; createHeart(); 
                } else if (dist > 0.3 && isFist) {
                    isFist = false;
                    currentMsgIndex = (currentMsgIndex + 1) % MESSAGES.length;
                    createTextShape(MESSAGES[currentMsgIndex]);
                }
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            const pos = particles.geometry.attributes.position.array;
            for(let i=0; i<particleCount*3; i++) {
                pos[i] += (targetPositions[i] - pos[i]) * LERP_SPEED;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        document.getElementById('start-btn').onclick = () => {
            document.getElementById('overlay').style.opacity = 0;
            setTimeout(() => document.getElementById('overlay').style.display = 'none', 800);
            init();
            const video = document.getElementById('video');
            const cam = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 480, height: 640 // Proporción de celular
            });
            cam.start();
        };
    </script>
</body>
</html>
